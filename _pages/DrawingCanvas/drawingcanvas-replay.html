---
layout: default-blankwide
permalink: /DrawingCanvas/Replay/DrawingCanvas
title: "Pixel Pandemonium"
excerpt: "Pixel Pandemonium"
    
canvascolors: 14  
    
numrows: 12
numcols: 26

subcols: 5
subrows: 3

canvaswidth: 1560
canvasheight: 432

colorpickerwidth: 64
colorpickerheight: 64

instructionsjs: "../../files/drawingcanvas-cs4allpa2022/Post-It_CSforALLinPA_RWB_bk_v6x_composite.js"

dogrid: true
dofreedraw: false

fayelink: "https://FayePubSub.jpopyack.repl.co"
replaylink: "https://ReplayDataStore.jpopyack.repl.co"
replaysleepms: 10

instructionswidth: 896
instructionsheight: 504

rectangleepsilon: 1

clickable: false

finishedvideo: 
  link: "./Reveal"
  text: "Click to see your finished videos here!"

citation: "We are indebted to Dr. Jane E. Huggins, Associate Research Scientist at the University of Michigan, Ann Arbor, for providing the image that graces the left side of the screen."

---

<style>
#canvascontainer {
 width: {{ page.canvaswidth | plus:100 }}px;
 height: {{ page.canvasheight | plus:10 }}px;
}

#yheadercanvascontainer {   
 float: left;
 width: 50px;
 height: {{ page.canvasheight }}px;
 margin: 0;
 padding: 0;
 display: inline-block;
}

#maincanvascontainer { 
 float: left;
 width: {{ page.canvaswidth }}px;
 height: {{ page.canvasheight }}px;
 margin: 0;
 padding: 0;
 display: inline-block;
}
</style>

{% if page.fayelink %}
<!-- Run corresponding repl.it -->
<script type="text/javascript" 
        src="{{ page.fayelink }}/faye/client.js">
        </script>
{% endif %}

<script language="javascript" type="text/javascript" src="{{ page.instructionsjs }}?t={{ site.time | date_to_xmlschema }}"></script>
        
<!-- https://medium.com/@joehanson/multi-user-javascript-virtual-whiteboard-28e4b24ef3e2 -->

<!-- Set color palette and dimensions above according to mail merge post it posterizer colors and drawing grid, if using post-its; create and give out mail merge document -->

<canvas id="xheadercanvas" width="{{ page.canvaswidth | plus:150 }}" height="50" style="border:0px solid #ffffff;"></canvas>
<br>
<div id="canvascontainer">
<div id="yheadercanvascontainer">
<canvas id="yheadercanvas" width="50" height="{{ page.canvasheight }}" style="border:0px solid #ffffff;"></canvas>
</div>
<div id="maincanvascontainer">
<canvas id="drawCanvas" width="{{ page.canvaswidth }}" height="{{ page.canvasheight }}" style="border:1px solid #000000;"></canvas>
</div>
</div>

<br><br>

{% if page.clickable %}
<div id="colorpicker" style="max-width:{{ page.instructionswidth | default: 560}}px;">
{% for i in (0..page.canvascolors) %}
{% if i < page.canvascolors %}
<canvas id="canvascolor{{ i }}" width="{{ page.colorpickerwidth }}" height="{{ page.colorpickerheight }}" style="border:1px solid #000000;"></canvas>
{% endif %}
{% endfor %}
</div>

<br>
{% endif %}

{% if page.instructionstext %}
<br>
<div id="instructionstext" style="max-width:{{ page.instructionswidth | default: 560}}px;">
<strong>What to Do:</strong><br>
{{ page.instructionstext }}
</div>
<br>
{% endif %}

{% if page.instructionslink %}
<br>
<div id="instructionslink" style="max-width:{{ page.instructionswidth | default: 560}}px;">
<a href="{{ page.instructionslink }}" target="_blank">Click here for the Instructions</a>
</div>
<br>
{% endif %}

{% if page.finishedvideo %}
<center>
<a href="{{page.finishedvideo.link}}">{{page.finishedvideo.text}}</a>
</center>
<br>
{% endif %}

{% if page.citation %}
<center>
{{ page.citation }}
</center>
<br>
{% endif %}

<br>

{% if page.links %}
{% for i in (0..page.links.size) %}
{% if i < page.links.size %}
<a href="{{page.links[i].link}}">{{page.links[i].title}}</a><br>
{% endif %}
{% endfor %}
{% endif %}

<br>

{% if page.clickable %}
<!-- Color chooser is set by the color picker -->
<input type="color" id="colorpicker" name="colorpicker" value="#ff0000" style="visibility: hidden">
{% endif %}

<!-- video -->
<br>
<div id="videoDiv">Video here</div>
<script src="https://raw.githubusercontent.com/antimatter15/whammy/master/whammy.js"></script>
<script type="text/javascript">
    // https://riptutorial.com/html5-canvas/example/19522/capture-canvas-and-save-as-webm-video
    var Groover = (function(){
        // ensure webp is supported 
        function canEncode(){
            var canvas = document.createElement("canvas");
            canvas.width = 8;
            canvas.height = 8;
            return canvas.toDataURL("image/webp",0.1).indexOf("image/webp") > -1;
        }
        if(!canEncode()){
            return undefined;
        }    
        var webmData = null;
        var clusterTimecode = 0;
        var clusterCounter = 0;
        var CLUSTER_MAX_DURATION = 30000;
        var frameNumber = 0;
        var width;
        var height;
        var frameDelay;
        var quality;
        var name;
        const videoMimeType = "video/webm"; // the only one.
        const frameMimeType = 'image/webp'; // can be no other
        const S = String.fromCharCode;
        const dataTypes = {
            object : function(data){ return toBlob(data);},
            number : function(data){ return stream.num(data);},
            string : function(data){ return stream.str(data);},
            array  : function(data){ return data;}, 
            double2Str : function(num){
                var c = new Uint8Array((new Float64Array([num])).buffer);
                return S(c[7]) + S(c[6]) + S(c[5]) + S(c[4]) + S(c[3]) + S(c[2]) + S(c[1]) + S(c[0]);
            }
        };    
       
        const stream = {
            num : function(num){ // writes int
                var parts = [];
                while(num > 0){ parts.push(num & 0xff); num = num >> 8; }
                return new Uint8Array(parts.reverse());
            },
            str : function(str){ // writes string
                var i, len, arr;
                len = str.length;
                arr = new Uint8Array(len);
                for(i = 0; i < len; i++){arr[i] = str.charCodeAt(i);}
                return arr;
            },
            compInt : function(num){ // could not find full details so bit of a guess
                if(num < 128){       // number is prefixed with a bit (1000 is on byte 0100 two, 0010 three and so on)
                    num += 0x80;
                    return new Uint8Array([num]);
                }else
                if(num < 0x4000){
                    num += 0x4000;
                    return new Uint8Array([num>>8, num])
                }else
                if(num < 0x200000){
                    num += 0x200000;
                    return new Uint8Array([num>>16, num>>8, num])
                }else
                if(num < 0x10000000){
                    num += 0x10000000;
                    return new Uint8Array([num>>24, num>>16, num>>8, num])
                }            
            }
        }
        const ids = { // header names and values
            videoData          : 0x1a45dfa3, 
            Version            : 0x4286,
            ReadVersion        : 0x42f7,
            MaxIDLength        : 0x42f2,
            MaxSizeLength      : 0x42f3,
            DocType            : 0x4282,
            DocTypeVersion     : 0x4287,
            DocTypeReadVersion : 0x4285,
            Segment            : 0x18538067,
            Info               : 0x1549a966,
            TimecodeScale      : 0x2ad7b1,
            MuxingApp          : 0x4d80,
            WritingApp         : 0x5741,
            Duration           : 0x4489,
            Tracks             : 0x1654ae6b,
            TrackEntry         : 0xae,
            TrackNumber        : 0xd7,
            TrackUID           : 0x63c5,
            FlagLacing         : 0x9c,
            Language           : 0x22b59c,
            CodecID            : 0x86,
            CodecName          : 0x258688,
            TrackType          : 0x83,
            Video              : 0xe0,
            PixelWidth         : 0xb0,
            PixelHeight        : 0xba,
            Cluster            : 0x1f43b675,
            Timecode           : 0xe7,
            Frame              : 0xa3,
            Keyframe           : 0x9d012a,
            FrameBlock         : 0x81,
        };
        const keyframeD64Header = '\x9d\x01\x2a'; //VP8 keyframe header 0x9d012a
        const videoDataPos = 1; // data pos of frame data header
        const defaultDelay = dataTypes.double2Str(1000/25);
        const header = [  // structure of webM header/chunks what ever they are called.
            ids.videoData,[
                ids.Version, 1,
                ids.ReadVersion, 1,
                ids.MaxIDLength, 4,
                ids.MaxSizeLength, 8,
                ids.DocType, 'webm',
                ids.DocTypeVersion, 2,
                ids.DocTypeReadVersion, 2
            ],
            ids.Segment, [
                ids.Info, [
                    ids.TimecodeScale, 1000000,
                    ids.MuxingApp, 'Groover',
                    ids.WritingApp, 'Groover',
                    ids.Duration, 0
                ],
                ids.Tracks,[
                    ids.TrackEntry,[
                        ids.TrackNumber, 1,
                        ids.TrackUID, 1,
                        ids.FlagLacing, 0,     // always o
                        ids.Language, 'und',   // undefined I think this means
                        ids.CodecID, 'V_VP8',  // These I think must not change
                        ids.CodecName, 'VP8',  // These I think must not change
                        ids.TrackType, 1,
                        ids.Video, [
                            ids.PixelWidth, 0,
                            ids.PixelHeight, 0
                        ]
                    ]
                ]
            ]
        ];    
        function getHeader(){
            header[3][2][3] = name;
            header[3][2][5] = name;
            header[3][2][7] =  dataTypes.double2Str(frameDelay);
            header[3][3][1][15][1] =  width;
            header[3][3][1][15][3] =  height;
            function create(dat){
                var i,kv,data;
                data = [];
                for(i = 0; i < dat.length; i += 2){
                    kv = {i : dat[i]};
                    if(Array.isArray(dat[i + 1])){
                        kv.d = create(dat[i + 1]);
                    }else{
                        kv.d = dat[i + 1];
                    }
                    data.push(kv);
                }
                return data;
            }
            return create(header);
        }
        function addCluster(){
            webmData[videoDataPos].d.push({ i: ids.Cluster,d: [{ i: ids.Timecode, d: Math.round(clusterTimecode)}]}); // Fixed bug with Round
            clusterCounter = 0;
        }
        function addFrame(frame){
            var VP8, kfS,riff;
            riff = getWebPChunks(atob(frame.toDataURL(frameMimeType, quality).slice(23)));
            VP8 = riff.RIFF[0].WEBP[0];
            kfS = VP8.indexOf(keyframeD64Header) + 3;
            frame = {
                width: ((VP8.charCodeAt(kfS + 1) << 8) | VP8.charCodeAt(kfS)) & 0x3FFF,
                height: ((VP8.charCodeAt(kfS + 3) << 8) | VP8.charCodeAt(kfS + 2)) & 0x3FFF,
                data: VP8,
                riff: riff
            };
            if(clusterCounter > CLUSTER_MAX_DURATION){
                addCluster();            
            }
            webmData[videoDataPos].d[webmData[videoDataPos].d.length-1].d.push({
                i: ids.Frame, 
                d: S(ids.FrameBlock) + S( Math.round(clusterCounter) >> 8) +  S( Math.round(clusterCounter) & 0xff) + S(128) + frame.data.slice(4),
            });
            clusterCounter += frameDelay;        
            clusterTimecode += frameDelay;
            webmData[videoDataPos].d[0].d[3].d = dataTypes.double2Str(clusterTimecode);
        }
        function startEncoding(){
            frameNumber = clusterCounter = clusterTimecode = 0;
            webmData  = getHeader();
            addCluster();
        }    
        function toBlob(vidData){
            var data,i,vData, len;
            vData = [];
            for(i = 0; i < vidData.length; i++){
                data = dataTypes[typeof vidData[i].d](vidData[i].d);
                len  = data.size || data.byteLength || data.length;
                vData.push(stream.num(vidData[i].i));
                vData.push(stream.compInt(len));
                vData.push(data)
            }
            return new Blob(vData, {type: videoMimeType});
        }
        function getWebPChunks(str){
            var offset, chunks, id, len, data;
            offset = 0;
            chunks = {};
            while (offset < str.length) {
                id = str.substr(offset, 4);
                // value will have top bit on (bit 32) so not simply a bitwise operation
                // Warning little endian (Will not work on big endian systems)
                len = new Uint32Array(
                    new Uint8Array([
                        str.charCodeAt(offset + 7),
                        str.charCodeAt(offset + 6),
                        str.charCodeAt(offset + 5),
                        str.charCodeAt(offset + 4)
                    ]).buffer)[0];
                id = str.substr(offset, 4);
                chunks[id] = chunks[id] === undefined ? [] : chunks[id];
                if (id === 'RIFF' || id === 'LIST') {
                    chunks[id].push(getWebPChunks(str.substr(offset + 8, len)));
                    offset += 8 + len;
                } else if (id === 'WEBP') {
                    chunks[id].push(str.substr(offset + 8));
                    break;
                } else {
                    chunks[id].push(str.substr(offset + 4));
                    break;
                }
            }
            return chunks;
        }
        function Encoder(fps, _quality = 0.8, _name = "Groover"){ 
            this.fps = fps;
            this.quality = quality = _quality;
            this.frameDelay = frameDelay = 1000 / fps;
            this.frame = 0;
            this.width = width = null;
            this.timecode = 0;
            this.name = name = _name;
        }
        Encoder.prototype = {
            addFrame : function(frame){
                if('canvas' in frame){
                    frame = frame.canvas;    
                }
                if(width === null){
                    this.width = width = frame.width,
                    this.height = height = frame.height
                    startEncoding();
                }else
                if(width !== frame.width || height !== frame.height){
                    throw RangeError("Frame size error. Frames must be the same size.");
                }            
                addFrame(frame);   
                this.frame += 1;
                this.timecode = clusterTimecode;
            },        
            toBlob : function(){
                return toBlob(webmData);
            }
        }
        return {
            Video: Encoder,
        }
    })()

    // https://riptutorial.com/html5-canvas/example/19522/capture-canvas-and-save-as-webm-video
    name = "CanvasCapture"; // Placed into the Mux and Write Application Name fields of the WebM header
    quality = 0.7; // good quality 1 Best < 0.7 ok to poor
    fps = 30; // I have tried all sorts of frame rates and all seem to work
              // Do some test to workout what your machine can handle as there
              // is a lot of variation between machines.
    var canvas = document.getElementById("drawCanvas"); 
    var videoDiv = document.getElementById("videoDiv");    
              
    var video = new Groover.Video(fps,quality,name)
    function capture(){
        if(video.timecode < 5000){ // 5 seconds
             setTimeout(capture,video.frameDelay);             
        }else{
             var videoElement = document.createElement("video");
             videoDiv.appendChild(videoElement);
             
             videoElement.src = URL.createObjectURL(video.toBlob());
             document.body.appendChild(videoElement);
             video = undefined; // DeReference as it is memory hungry.
             return;
        }
        // first frame sets the video size
        video.addFrame(canvas); // Add current canvas frame
    }
    capture(); // start capture
</script>
<!-- end video -->

<br><br>

<script type="text/javascript">
var canvas = document.getElementById('drawCanvas');
var ctx = canvas.getContext('2d');
var colorpicker = document.getElementById('colorpicker');

ctx.lineWidth = '3';

{% if page.clickable %}
// https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
function rgbToHex(r, g, b) {
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// palettes for pre made color choosers; will be placed sequentially into numbered canvascolorN elements
var palettes = [];
for(var i = 0; i < {{ page.canvascolors }} && i < palette.length; i++) {
    palettes.push(rgbToHex(palette[i][0], palette[i][1], palette[i][2])); // palette defined in post it instructionsjs
}
function colorpaletteclicked(e) {
    var id = e.target.id;
    
    id = id.replace("canvascolor", "");
    
    id = parseInt(id);
    
    chosencolor = palettes[id];
    
    colorpicker.value = chosencolor;
    
    //console.log(id);
    //console.log(chosencolor);
}

function makeColorPalette(colorcanvas, fillcolor, label) {
    var colorctx = colorcanvas.getContext('2d');
    
    // Color it in with the predefined palette
    colorctx.fillStyle = fillcolor;
    colorctx.fillRect(0, 0, colorcanvas.width, colorcanvas.height);
    
    // Label the color with a number
    colorctx.font = "18px Arial";
    if(fillcolor == '#000000') {
        colorctx.fillStyle = "white";    
        colorctx.strokeStyle = "white";         
    } else {
        colorctx.fillStyle = "black";    
        colorctx.strokeStyle = "black"; 
    }
    colorctx.fillText(label, (colorcanvas.width / 2.0) * 0.9, (colorcanvas.height / 2.0) * 0.9);
}

function makeColorPalettes() {
    for(var i = 0; i < palettes.length; i++) {
        var colorcanvas = document.getElementById('canvascolor' + i);
        makeColorPalette(colorcanvas, palettes[i], i);
        
        // Add a listener here that, when clicked, sets the main color picker color value
        colorcanvas.addEventListener('mousedown', colorpaletteclicked, false);        
    }
}

makeColorPalettes();
{% endif %}

{% if page.dogrid %}
// ***** OPTION: GRID SUPPORT *****
// for labeling the grid
var xlabels = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

// canvas width is 800x600 by default; use these to set the number of elements: 800/width = num cols, 600/height = num rows
// note that numcols must be < 26, otherwise a conversion must be written to go from column letter to number beyond one character (see .charCodeAt(0)) in all pages
var numcols = {{ page.numcols }}; 
var numrows = {{ page.numrows }}; 
var gridwidth = {{ page.canvaswidth }} / numcols;
var gridheight = {{ page.canvasheight }} / numrows;

// subcols and subrows provide subsquares within each grid element for the individual fill-ins
var subcols = {{ page.subcols }};
var subrows = {{ page.subrows }};

{% if page.clickable %}
function gridListeners() {
    canvas.addEventListener('mousedown', fillgrid, false);
}
{% endif %}

{% if page.replaylink %}
{% if page.clickable %}
function doReplaySend(leftx, topy, gridwidth, subcols, gridheight, subrows, colorvalue, xsquare, ysquare) {
    message = leftx + "," + topy + "," + gridwidth / subcols + "," + gridheight / subrows + "," + colorvalue + "," + xsquare + "," + ysquare;
    
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "{{ page.replaylink }}/insert", true);
    
    xhr.onreadystatechange = function () {
        if (this.readyState != 4) return;

        if (this.status == 200) {
            var data = JSON.parse(this.responseText);

            console.log("Replay Message Sent");
        }
    };
    
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
    xhr.send("data=" + message);
}
{% endif %}

function doReplayDispatch(data, i) {
    if(i < data.length) {
        row = data[i];
        
        id = row[0];
        timestamp = row[1];
        msg = row[2];
        
        var msgparts = msg.split(',');
        
        var leftx = msgparts[0];
        var topy = msgparts[1];
        var rectwidth = msgparts[2];
        var rectheight = msgparts[3];
        var rectcolor = msgparts[4];
        var xsquare = msgparts[5];
        var ysquare = msgparts[6];
        
        {% if page.replaysleepms %}                
        var delayTime = {{ page.replaysleepms }};
        {% else %}
        var delayTime = 0;
        {% endif %}
        
        // sleep to animate re-drawing from the beginning
        drawGridSquare(leftx, topy, rectwidth, rectheight, rectcolor, xsquare, ysquare); 
        
        setTimeout(function() { 
            // call drawrect method
            doReplayDispatch(data, i+1);
         }, delayTime); 
    }
}

function doReplayGet() {    
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "{{ page.replaylink }}/retrieve", true);
    
    xhr.onreadystatechange = function () {
        if (this.readyState != 4) return;

        if (this.status == 200) {
            var data = JSON.parse(this.responseText);

            console.log("Replay Message Retrieved");
            console.log(data);
            
            doReplayDispatch(data, 0);
        }
    };
    
    xhr.send();   
}
{% endif %}

{% if page.fayelink %}
// Pub-sub
var fayeclient = new Faye.Client('{{ page.fayelink }}');

function doFayeSubscribe() {
  fayeclient.subscribe('/messages', function(message) {
    //console.log("Message: " + message.text);
    
    var msg = message.text;
    var msgparts = msg.split(',');
    
    var leftx = msgparts[0];
    var topy = msgparts[1];
    var rectwidth = msgparts[2];
    var rectheight = msgparts[3];
    var rectcolor = msgparts[4];
    var xsquare = msgparts[5];
    var ysquare = msgparts[6];
    
    // call drawrect method
    drawGridSquare(leftx, topy, rectwidth, rectheight, rectcolor, xsquare, ysquare);
  });    
}

{% if page.clickable %}
function doFayeSend(leftx, topy, gridwidth, subcols, gridheight, subrows, colorvalue, xsquare, ysquare) {
    message = leftx + "," + topy + "," + gridwidth / subcols + "," + gridheight / subrows + "," + colorvalue + "," + xsquare + "," + ysquare;
    
    fayeclient.publish('/messages', {
      text: message
    });     
}
{% endif %}
{% endif %}

// call this to initialize the grid; comment to disable
makeGrid(canvas.width, canvas.height, gridwidth, gridheight);

{% if page.clickable %}
// call this to add click listener to fill in rectangle; comment to disable
gridListeners();
{% endif %}

{% if page.fayelink %}
// call this to set up pub-sub; comment to disable
doFayeSubscribe();
{% endif %}

{% if page.replaylink %}
// retrieve and draw the board
doReplayGet();
{% endif %}

// https://stackoverflow.com/questions/11735856/draw-grid-table-on-canvas-html5
// bwidth/bheight is the dimension of the canvas board, and rwidth/rheight is the dimension of the rectangle in the grid
function makeGrid(bwidth, bheight, rwidth, rheight) {
    ctx.strokeStyle = "black";
    
    var xlines = -1;
    
    for (var x = 0; x <= bwidth + 1; x += rwidth / subcols) {
        xlines = xlines + 1;
        
        if(xlines == subcols) {
            xlines = 0;
        }
        
        if(xlines == 0) {
            ctx.lineWidth = '3';
        } else {
            ctx.lineWidth = '1';
        }
        
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, bheight);
        ctx.stroke();
    }

    var ylines = -1;
    
    for (var y = 0; y <= bheight + 1; y += rheight / subrows) {
        ylines = ylines + 1;
        
        if(ylines == subrows) {
            ylines = 0;
        }
    
        if(ylines == 0) {
            ctx.lineWidth = '3';
        } else {
            ctx.lineWidth = '1';
        }
                
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(bwidth, y);
        ctx.stroke();
    }
    
    ctx.font = "18px Arial";
    ctx.strokeStyle = "red";
    ctx.fillStyle = "red";
    ctx.lineWidth = '3';
    
    var xi = 0;
    var yi = 0;
    for(var x = 0; x < bwidth; x += rwidth) {
        yi = 0;
        
        for(var y = 0; y < bheight; y += rheight) {
            label = xlabels.charAt(xi % xlabels.length) + (yi + 1).toString(); 
            
            // duplicate the letter i.e. AA if there are more than 26 lettered columns
            var repeats = Math.floor(xi / xlabels.length);
            for(var z = 0; z < repeats; z++) {
                label = xlabels.charAt(xi % xlabels.length) + label;
            }
            
            ctx.fillText(label, x + (rwidth / 2.0) - (rwidth / 10.0), y + (rheight / 2.0));
            
            yi = yi + 1;
        }
        
        xi = xi + 1;
    }
    
    ctx.strokeStyle = "black";
    ctx.fillStyle = "black";    
    ctx.lineWidth = '3';
    
    // Fill in the x header labels
    var xheadercanvas = document.getElementById('xheadercanvas');
    var xheaderctx = xheadercanvas.getContext('2d');
    
    xheaderctx.font = "18px Arial";
    xheaderctx.strokeStyle = "red";
    xheaderctx.fillStyle = "red";
    xheaderctx.lineWidth = '3';
    
    var xi = 0;
    for(var x = 0; x < bwidth; x += rwidth) {
        label = xlabels.charAt(xi % xlabels.length);
        
        // duplicate the letter i.e. AA if there are more than 26 lettered columns
        var repeats = Math.floor(xi / xlabels.length);
        for(var z = 0; z < repeats; z++) {
            label = xlabels.charAt(xi % xlabels.length) + label;
        }
            
        xheaderctx.fillText(label, x + (rwidth / 2.0) + 50, 25);
        
        //console.log(x + " (" + xi + "): " + label + " (" + rwidth + ", " + bwidth + ")");
        
        xi = xi + 1;
    }   

    // Fill in the y header labels
    var yheadercanvas = document.getElementById('yheadercanvas');
    var yheaderctx = yheadercanvas.getContext('2d');
    
    yheaderctx.font = "18px Arial";
    yheaderctx.strokeStyle = "red";
    yheaderctx.fillStyle = "red";
    yheaderctx.lineWidth = '3';
    
    var yi = 0;
    for(var y = 0; y < bheight; y += rheight) {
        label = (yi + 1).toString(); 
        yheaderctx.fillText(label, 25, y + (rheight / 2.0));
        
        yi = yi + 1;
    }       
}

function drawGridSquare(leftx, topy, rectwidth, rectheight, rectcolor, xsquare, ysquare) {
    ctx.fillStyle = rectcolor;
    
    var origleftx = leftx;
    var origtopy = topy;
    var origrectwidth = rectwidth;
    var origrectheight = rectheight;
    
    // Where is this grid square?  If it is known, override original x and y coordinates with these in case the dimensions have changed.  Otherwise, calculate it from the coordinates given.
    if(typeof xsquare == 'undefined' && typeof ysquare == 'undefined') {
        xsquare = Math.floor(1.0 * leftx / rectwidth);
        ysquare = Math.floor(1.0 * topy / rectheight);
    }
    
    leftx =  xsquare * (1.0 * gridwidth / subcols);
    topy =  ysquare * (1.0 * gridheight / subrows);
    rectwidth = (1.0 * gridwidth / subcols);
    rectheight = (1.0 * gridheight / subrows);    
    
    console.log("Drawing Grid Square: " + leftx + ", " + topy + ", " + rectwidth + ", " + rectheight + ", " + rectcolor + ", " + xsquare + ", " + ysquare + "; originally: " + origleftx + ", " + origtopy + ", " + origrectwidth + ", " + origrectheight);    
    
    // Fill in that rectangle
    ctx.fillRect(leftx + {{ page.rectangleepsilon | default: 0}},topy + {{ page.rectangleepsilon | default: 0}},rectwidth - {{ page.rectangleepsilon | default: 0}},rectheight - {{ page.rectangleepsilon | default: 0}});
}

{% if page.clickable %}
function fillgrid(e) {
    if(e.button != 0) { // left click only
        return;
    }
    
    // cross-browser canvas coordinates
    var x = e.offsetX || e.layerX - canvas.offsetLeft;
    var y = e.offsetY || e.layerY - canvas.offsetTop;
    
    // What grid rectangle are we in?
    var xsquare = Math.floor(x * 1.0 / (gridwidth / subcols));
    var ysquare = Math.floor(y * 1.0 / (gridheight / subrows));
    var leftx =  xsquare * (1.0 * gridwidth / subcols);
    var topy =  ysquare * (1.0 * gridheight / subrows);
    
    drawGridSquare(leftx, topy, gridwidth / subcols, gridheight / subrows, colorpicker.value, xsquare, ysquare);
    
    {% if page.fayelink %}
    // Send message to faye
    doFayeSend(leftx, topy, gridwidth, subcols, gridheight, subrows, colorpicker.value, xsquare, ysquare);
    {% endif %}
    
    {% if page.replaylink %}
    // Send to database
    doReplaySend(leftx, topy, gridwidth, subcols, gridheight, subrows, colorpicker.value, xsquare, ysquare);
    {% endif %}
}
{% endif %}
// ***** END OPTION: GRID SUPPORT *****
{% endif %}

{% if page.dofreedraw %}
// ***** OPTION: FREE DRAW SUPPORT *****
// create a flag for free drawing (if pen is on or off)
var isActive = false;

// array to collect coordinates for free drawing
var plots = [];

{% if page.clickable %}
function freeDrawListeners() {
    canvas.addEventListener('mousedown', startDraw, false);
    canvas.addEventListener('mousemove', draw, false);
    canvas.addEventListener('mouseup', endDraw, false);
}

// call this to add free draw listeners to attach the pen to the mouse; comment to disable
freeDrawListeners();

function drawOnCanvas() {
  //console.log(plots[0].x);
  //console.log(plots[0].y);
  
  color = colorpicker.value;
  
  //console.log(color);
  
  ctx.strokeStyle = color;
  
  ctx.beginPath();
  ctx.moveTo(plots[0].x, plots[0].y);

  for(var i=1; i<plots.length; i++) {
    ctx.lineTo(plots[i].x, plots[i].y);
  }
  ctx.stroke();
}

function draw(e) {
  if(!isActive) return;

  // cross-browser canvas coordinates
  var x = e.offsetX || e.layerX - canvas.offsetLeft;
  var y = e.offsetY || e.layerY - canvas.offsetTop;

  plots.push({x: x, y: y});
  
  drawOnCanvas();
}

function startDraw(e) {
  if(e.button != 0) { // left click only
      return;
  }
    
  isActive = true;
}

function endDraw(e) {
  isActive = false;

  // empty the array
  plots = [];
}
{% endif %}
// ***** END OPTION: FREE DRAW SUPPORT *****
{% endif %}
</script>
